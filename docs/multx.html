<!DOCTYPE html>
<html>

<link href="styles.css" rel="stylesheet">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>multx</title>
</head>

<body>



<h2>multx - Executing Commands on Multiple Remote Linux/UNIX Hosts</h2>

multx (MULTiple eXecution) is an ssh tool that invokes the same command(s) on multiple "target" hosts.
multx can execute these command(s) either sequentially (foreground) or in parallel (background).
multx has only a few command line arguments, so <font size="+3">&#8747;</font><i>knowledge dt</i> is tiny.

It's useful when you must execute commands on multiple *NIX hosts and you don't have access
to a working configuration management tool that you know how to use.
<p>

Use these 3 very, very simple shell scripts to execute commands on remote hosts - possibly lots of them -
<b>without typing passwords or passphrases</b> - except for the initial setup, of course!

<ul class="padbottom">
    <li><b>multx</b> - The script that actually executes the
	commands on the remote hosts. To be most useful, use multx together with the two scripts below.
	multx will almost certainly need to be edited to reflect local hostnames/IP addresses. That is:
	<p>
	<font color="blue"><b>multx is a <u>template</u> to be edited as required.</b></font>
    </li>
    <li><b>start-ssh-agent</b> - The script that sets up
	ssh-agent and the environment. This can be shared by multiple users, e.g., put in /usr/local/bin.
    </li>
    <li><b>stop-ssh-agent</b> - The script that stops ssh-agent
	and cleans up the environment. This can be also be shared by multiple users.
    </li>
</ul>

Download all three of these utilities from the <a href="https://github.com/JamesSCrook/multx.git"><b>multx</b></a>
github repo.
<p>

Of course, once ssh-agent is running with the correct environment, all other commands that are based on ssh
will work without being prompted for authentication as well. For example, scp and rsync.


<h3>The Default multx Usage Message</h3>
<div style="overflow:auto; background:#CCFFCC">
<pre>
usage (version 1.0.0):
multx [option(s)] remote_command
  Where options are: 123abch:f:o:qs:x:
    -1			:+ hostnames: fred wilma
    -2			:+ hostnames: barney betty
    -3			:+ hostnames: pebbles bamm-bamm
    -a			:+ hostnames: fred wilma barney betty pebbles bamm-bamm
    -b			:  background mode
    -c			:  confirmation mode
    -h host_list	:+ add a hostname or 'hostname_1 ... hostname_n'
    -f file		:+ read a file containing hostname(s)
    -o outfilepat	:  output file pattern ("'${HOSTNAME}.info'" is a useful choice)
    -q			:  quiet mode
    -s ssh_arg(s)	:+ arguments to be passed to ssh
    -x ERE		:+ eXclude all/part of hostname(s) containing this ERE (pattern)
    '+' options may be used more than once and/or combined with others
multx Copyright (C) 2016-2017 James S. Crook
This program comes with ABSOLUTELY NO WARRANTY and is distributed under the FreeBSD license.

</pre>
</div>

<h3>Preparation: Configuring ssh and ssh-agent</h3>
Before one can use multx without typing passwords or passphrases every time, ssh must be configured
on all the machines and ssh-agent on at least one. Information on how to do this is found in many
places on the web, one of those is in the <a href="#appendix">appendix</a> at the bottom of this page.

<h3>Simple Examples of Running multx</h3>
Note that typing passwords or passphrases is not required in any of the examples below.
Also, it would be just as easy to run remote commands on 100 target hosts as on a few.
<ol class="padbottom">

    <li>Running hostname on set 1 of hosts (foreground):
<pre>
$ <b>multx -1 hostname</b>
Sat Feb 13 15:37:08 AEDT 2016 : multx starting
fred === &lthostname&gt ===
fred

wilma === &lthostname&gt ===
wilma

Sat Feb 13 15:37:17 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Running hostname on set 1 of hosts (background):
<pre>
$ <b>multx -1b hostname</b>
Sat Feb 13 15:38:09 AEDT 2016 : multx starting
fred === &lthostname&gt ===

wilma === &lthostname&gt ===

wilma
fred
Sat Feb 13 15:38:09 AEDT 2016 : multx finished
</pre>
    Note that the order of the output is non-deterministic when using the background option!
    </li>

    <li>Creating a file with date on all hosts (background):
<pre>
$ <b>multx -ab 'date > /tmp/junk'</b>
Sat Feb 13 15:42:46 AEDT 2016 : multx starting
fred === &ltdate > /tmp/junk&gt ===

wilma === &ltdate > /tmp/junk&gt ===

barney === &ltdate > /tmp/junk&gt ===

betty === &ltdate > /tmp/junk&gt ===

pebbles === &ltdate > /tmp/junk&gt ===

bamm-bamm === &ltdate > /tmp/junk&gt ===

Sat Feb 13 15:42:48 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Using sed to "edit" a file [create a modified new file] (background)"
<pre>
$ <b>multx -ab 'sed s/2016/1492/ /tmp/junk > /tmp/rubbish'</b>
Sat Feb 13 15:45:41 AEDT 2016 : multx starting
fred === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

wilma === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

barney === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

betty === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

pebbles === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

bamm-bamm === &ltsed s/2016/1492/ /tmp/junk > /tmp/rubbish&gt ===

Sat Feb 13 15:45:42 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Listing the contents of a file with cat (foreground):
<pre>
$ <b>multx -a 'cat /tmp/rubbish'</b>
Sat Feb 13 15:45:59 AEDT 2016 : multx starting
fred === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 12:42:47 AWST 1492

wilma === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 12:42:47 AWST 1492

barney === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 12:42:47 AWST 1492

betty === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 12:42:47 AWST 1492

pebbles === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 12:42:47 AWST 1492

bamm-bamm === &ltcat /tmp/rubbish&gt ===
Sat Feb 13 00:46:21 AWST 1492

Sat Feb 13 15:46:04 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Checking if all hosts have the same version of a file (background, quiet mode):
<pre>
$ <b>multx -abq 'echo $(cksum /etc/sysconfig/postfix) $(hostname) $(uname)' | sort</b>
409984396 9662 /etc/sysconfig/postfix barney Linux
409984396 9662 /etc/sysconfig/postfix betty Linux
409984396 9662 /etc/sysconfig/postfix fred Linux
409984396 9662 /etc/sysconfig/postfix wilma Linux
452371448 14776 /etc/sysconfig/postfix bamm-bamm Linux
452371448 14776 /etc/sysconfig/postfix pebbles Linux
Sat Feb 13 15:43:06 AEDT 2016 : multx starting
Sat Feb 13 15:43:08 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Checking if all hosts have the correct date (background, quiet mode):
<pre>
$ <b>multx -abq 'echo $(date) $(hostname)' | sort</b>
Sat Feb 13 17:00:16 AWST 2016 bamm-bamm
Sun Feb 14 04:56:41 AWST 2016 barney
Sun Feb 14 04:56:41 AWST 2016 betty
Sun Feb 14 04:56:41 AWST 2016 fred
Sun Feb 14 04:56:41 AWST 2016 pebbles
Sun Feb 14 04:56:41 AWST 2016 wilma
Sun Feb 14 07:56:40 AEDT 2016 : multx starting
Sun Feb 14 07:56:42 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Displaying a particular line of interest from a particular file (background, quiet mode):
<pre>
$ <b>multx -abq 'echo $(hostname) : $(grep ^users: /etc/group)' | sort</b>
bamm-bamm : users:x:100:mux
barney : users:x:100:lux,mux
betty : users:x:100:mux
fred : users:x:100:tux,lux,mux
pebbles : users:x:100:lux,mux
wilma : users:x:100:lux,mux
Sun Feb 14 07:55:06 AEDT 2016 : multx starting
Sun Feb 14 07:55:08 AEDT 2016 : multx finished
</pre>
    </li>

    <li>Running commands as root (with sudo) on the target host(s). In this example,
    'hostname' is run as your user ID  and calling sudo runs 'id' as root (background, quiet mode).
    Double quotes are particularly useful here:
<pre>
$ <b>multx -1bq 'printf "%-10s: %s\n" $(hostname) "$(sudo id)"' | sort</b>
fred      : uid=0(root) gid=0(root) groups=0(root),2000(nfsuser)
wilma     : uid=0(root) gid=0(root) groups=0(root),2000(nfsuser),2001(foouser)
Sun Feb 14 21:35:18 AEDT 2016 : multx starting
Sun Feb 14 21:35:19 AEDT 2016 : multx finished
</pre>
    <p>
    If sudo on the target(s) fails with a sudo tty error, for example:
<pre>
$ <b>multx -1q 'sudo id'</b>
Tue Apr  4 10:46:05 AEST 2017 : multx starting
sudo: sorry, you must have a tty to run sudo
sudo: sorry, you must have a tty to run sudo
Tue Apr  4 10:46:07 AEST 2017 : multx finished
</pre>
Tell multx to pass ssh the option(s) it needs to allow this access using '-s option(s)'.
Typically, "-s -t" or "-s -tt"):

<pre>
$ <b>multx -s -t -1q 'sudo id'</b>
Tue Apr  4 10:46:16 AEST 2017 : multx starting
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Connection to fred closed.
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Connection to wilma closed.
Tue Apr  4 10:46:18 AEST 2017 : multx finished
</pre>
    <p>
    Of course one can do much more interesting things than just 'id'. One can do literally
    anything. For example, stop/start services, or even stop/reboot the remote host(s)!
Specifying the multx background option ("-b") may require "-s -tt":
<pre>
$ <b>multx -s -tt -1bq sudo systemctl stop dse.service</b>
Tue Apr  4 10:46:16 AEST 2017 : multx starting
Connection to fred closed.
Connection to wilma closed.
Tue Apr  4 10:46:18 AEST 2017 : multx finished
</pre>
    </li>
    <li>Adding and/or deleting particular host(s):
<pre>
$ <b>multx -12bq -h pebbles -x barney -x wilma hostname</b>
- or, equivalently:
$ <b>multx -12bq -h pebbles -x 'barney|wilma' hostname</b>
Mon Mar  7 08:04:25 AEDT 2016 : multx starting
fred
betty
pebbles
Mon Mar  7 08:04:25 AEDT 2016 : multx starting
</pre>
    </li>
</ol>

Hopefully, the examples above convey the basic idea. Of course, multx can do many more
things than the simple examples above!

<h3>Rolling Out a New File</h3>

<ol class="padbottom">
    <li>Copy the new file (newfile) to all "target" hosts. This can be done in two ways:
	<p>
	<ol class="padbottom" type="i">
	    <li><u>If <b>all</b> the hosts are configured to be both "initiators" and "targets"</u>,
		(recommended, if practical) use this method. Call multx on the "original initiator"
		to execute scp on all the "target" hosts. This will copy newfile from the "original
		initiator" to newfile.tmp on <b>all</b> the target hosts (including to itself):
		<br>
		$ <b>multx -abq '. .ssh/ssh-agent; scp -p initiator:newfile newfile.tmp</b>
	    </li>
	    <li><u>If there is only one "initiator"</u>, one would have to copy to each "target" host
		in turn:
		<br>
		$ <b>scp -p newfile target_1:newfile.tmp</b>
		<br>
		...
		<br>
		$ <b>scp -p newfile target_N:newfile.tmp</b>
		<p>
		One quick and easy way to do this would be with a script like this:
<pre>
INITIATORNAME=$1; TARGETNAME=$2; shift; shift
for HOST in $*; do
    scp -p $INITIATORNAME $HOST:$TARGETNAME & 	# Launch in background for asynchronous copies
done
wait
</pre>
		And then execute that script:
		<br>
		$ <b>script newfile newfile.tmp target_1 target_2 ... target_N</b>
		<br>
		Launching each scp in the background means all the copies happen asynchronously.
		And, of course, no passwords or passphrases would be required.
	    </li>
	</ol>
    </li>

    <li>Make a backup of the original file (optional):
	<br>
	$ <b>multx -abq 'cp -p /usr/local/bin/file /usr/local/bin/file.save'</b>
    </li>

    <li>
	Install the new file:
	<br>
	$ <b>multx -abq 'cp newfile.tmp /usr/local/bin/file'</b>
    </li>

    <li>
	After a suitable period of time... Cleanup (optional):
	<br>
	$ <b>multx -abq 'rm newfile.tmp /usr/local/bin/file.save'</b>
    </li>
</ol>

<h3>Change the Same File on Multiple Hosts</h3>

<ol class="padbottom">
    <li>Create a new version of the file in every host:
	<p>
	On set 1 of hosts:
	<br>
	$ <b>multx -1bq 'sed "/^ *- seeds: *".*"$/s/\".*\"/\"1.1.1.1,2.2.2.2,3.3.3.3\"/"
	    /etc/dse/cassandra/cassandra.yaml > /tmp/new.yaml'</b>
	<p>
	On set 2 of hosts:
	<br>
	$ <b>multx -2bq 'sed "/^ *- seeds: *".*"$/s/\".*\"/\"4.4.4.4,5.5.5.5,6.6.6.6\"/"
	    /etc/dse/cassandra/cassandra.yaml > /tmp/new.yaml'</b>
    </li>
    <li>Check the new version on both sets hosts (optional, but strongly recommended):
	<br>
	$ <b>multx -12 'diff /etc/dse/cassandra/cassandra.yaml /tmp/new.yaml'</b>
	<br>
	or, alternately:
	<br>
	$ <b>multx -12qb 'echo $(diff /etc/dse/cassandra/cassandra.yaml /tmp/new.yaml) $(hostname)'
	    | sort</b>
    </li>
    <li>Update the configuration file with the modified version on both sets of hosts:
	<br>
	$ <b>multx -12bq 'cp /tmp/new.yaml /etc/dse/cassandra/cassandra.yaml'</b>
    </li>
</ol>
The only limit is your imagination!

<h3>Store Some Info from Each Target Host in a Named File on the Initiating Host</h3>

There are (as of version 0.1.0) at least two ways to do this. First, the easy way, using the
'-o outfilepat' method. Note that one must prevent the initiating system's shell from attempting to
evaluate ${HOSTNAME} by 'escaping' the $. This can be done by preceding the $ with a \
(\${HOSTNAME}) or by surrounding it with <u>single</u> quotes ('${HOSTNAME}').

<ol class="padbottom">
    <li>
	$ <b>multx -1qb -o '${HOSTNAME}.info' 'rpm -qa | sort'</b>
    </li>
    <li>
	If all the hosts are configured to be both "initiators" and "targets" and ssh-agent is running on
	all systems with a valid passphrase (see above), one could do the same thing 'old school' (the
	hard way):
	<p>
	$ <b>multx -1bq 'rpm -qa | sort > tmp/junk; . .ssh/ssh-agent.env; scp /tmp/junk fred:$(hostname).info; rm /tmp/junk'</b>
    </li>
</ol>

Both of these commands should produce files like the ones below on the "initiating" host
(which is fred in the second example)
- each of which contains the information requested. In this example, the information requested is
a sorted list of all the packages installed on each of the target hosts.
<pre>
3ddiag-0.742-32.25
a2ps-4.13-1326.37.1
aaa_base-11-6.99.100.1
acl-2.2.47-30.36.1
...
</pre>

<h3>Customizing multx to Your Environment(s)</h3>

Remember:
<font color="blue"><b>multx is a <u>template</u> to be edited as required.</b></font>
<p>
If, on the off chance, your hostnames are not Flintstones character names, but (say) Star Trek,
edit multx accordingly.
<p>
The required changes are obvious, and must be made in 4 places. In the Flintstones to Star Trek example:
<ol class="padbottom">
    <li>In the HOST_GROUP section:
	<ol class="padbottom" type="i">
	    <li>Change '-1' to '-C' (for Captains).</li>
	    <li>Change 'HOST_GROUP_1="..."' to 'HOST_GROUP_C="kirk picard sisko janeway archer"'.</li>
	    <li>Change '-2' to '-F' (for First officers).</li>
	    <li>Change 'HOST_GROUP_2="..."' to 'HOST_GROUP_F="spock riker nerys chakotay tpol worf"'.</li>
	    <li>Delete '-3' if it's not required.</li>
	</ol>
    </li>
    <li>Change 'OPTIONS=123abch:f:o:qx:' to 'OPTIONS='CFabch:f:o:qx:'
    </li>
    </li>
    <li>In the getopts case statement, make the obvious changes to the '1)' and '2)' lines and delete
	the line with '3)'
    </li>
    <li>In the usage message, make the obvious changes to the '-1' and '-2' lines and delete the
	'-3' line.
    </li>
</ol>
<p>

<h3>Using multx with -f hostnames_file</h3>

If you can't be bothered changing multx, it's possible to use it with the '-f file'
option (here specified twice). These must be files containing the relevant hostnames.
<p>
This example collects the packages installed on all the hosts in DC_1 and DC_2 (assuming these
two files exist and have valid contents, of course):
<p>
$ <b>multx -f DC_1_hostnames -f DC_2_hostnames -bq -o '$HOSTNAME.packages' 'rpm -qa | sort'</b>

<h3>Notes</h3>
<ol class="padbottom">
    <li>multx takes <u>your commands</u> and runs them on multiple hosts. If <u>your commands</u>
	do bad things, multx just causes those bad things to happen on multiple systems.
	<font color="red"><b>I take no responsibility whatsoever for any damage <u>you cause</u>
	when running <u>your commands</u> using multx!!!</u>
	</b></font>
    </li>
    <li><b><u>As with any parallel tool, be careful. If you make a mistake, you make it N times!</u></b>
    </li>
    <li>Everything on this web page assumes one is running bash, sh, or ksh. If you're still running
	csh after all these years, there's no hope for you!
    </li>
    <li>With the '-o outfilepat' option, '$H' works exactly like '$HOSTNAME'. If curly braces would be
	required by a shell, multx also requires them. E.g., '$HOSTNAME.info' does not require them,
	but '${HOSTNAME}_info' does.
    </li>
    <li>I've never had more than 20 hosts to test them all logging in to the "original initiator"
	simultaneously. I recall that I had to increase MaxStartups above the (then) default of 10 in
	/etc/ssh/sshd_config.
    </li>
    <li>To permit root to login using ssh, set PermitRoot to yes in /etc/ssh/sshd_config.
    </li>
    <li>Other tools such as pssh or clusterssh may also be useful. multx has always done
	everything I needed to do.
    </li>
    <li>In background (asynchronous) mode - where commands are running on lots of hosts at the same
	time - <u>and</u> the commands are generating output, it's possible that the output from some
	host(s) could become interspersed with the output from other(s). <b>The <u>only</u> time this
	has ever been observed in the wild is when multiple output-producing commands are issued in
	the same multx call.</b> For example, <b>multx -abq 'command_1; command_2'</b>. If this is a
	small problem, remove the '-b' option. If it's a big problem, let me know and I'll investigate.
    </li>
    <li>multx (& co) also runs on Cygwin. It has not been tested on *BSD.
    </li>
</ol>

<h3 id="appendix">Appendix: Configuring ssh-agent for multx (et al)</h3>

<ol class="padbottom">
    <li>Generate a public/private key pair on the "initiating" host - where multx will be launched.
    Note: the example below assumes that the .ssh directory does not already exist, and that ECDSA
    public keys are desired (e.g., not RSA or DSA).
<pre>
$ <b>ssh-keygen -t ecdsa</b>
Generating public/private ecdsa key pair.
Enter file in which to save the key (/home/tux/.ssh/id_ecdsa): <font color="red">Type "Enter" here to accept the default.</font>
Created directory '/home/tux/.ssh'.
Enter passphrase (empty for no passphrase): <font color="red">Type a long and complicated passphrase here.</font>
Enter same passphrase again: <font color="red">And again here.</font>
Your identification has been saved in /home/tux/.ssh/id_ecdsa.
Your public key has been saved in /home/tux/.ssh/id_ecdsa.pub.
The key fingerprint is:
SHA256:bB14DZJwYStCcQ+XBzDJITQzfV5FcqgW75q+eZzweXg tux@iceberg
The key's randomart image is:
+---[ECDSA 256]---+
|   .O+B=B=o++    |
|   . *+B=++=     |
|    . .o+*o .    |
|     . o+o..     |
|       .S..      |
|       .. .      |
|         * +     |
|        o.B E    |
|       .+o o     |
+----[SHA256]-----+
$ <b>ls -l ~/.ssh</b>
total 8
4 -rw-------. 1 tux tux 314 Feb 13 14:56 id_ecdsa
4 -rw-r--r--. 1 tux tux 172 Feb 13 14:56 id_ecdsa.pub
</pre>
    </li>
    <li>
	Enable public key authentication (for the above generated key pair) <u>on <b>all</b> the "target"
	hosts - where the commands will run</u>.  Note: this may well (and usually does) include the
	"initiating" host as well. (That is, calling ssh to itself.)
	<p>
	On all "target" hosts, ensure ~/.ssh exists with the correct owner, group and permissions:
<pre>
$ <b>mkdir ~/.ssh</b>		# user and group should be correct, chown if required
$ <b>chmod 700 ~/.ssh</b>
$ <b>ls -ld ~/.ssh</b>
drwx------. 2 tux tux 4096 Feb 13 15:13 /home/tux/.ssh/
</pre>
	Copy the "initiating" host's public key file ~/.ssh/id_ecdsa.pub from the "initiating" host to
	the authorized_keys file on <b>all</b> of the "target" hosts:
<pre>
$ <b>scp ~/.ssh/id_ecdsa.pub target_1:.ssh/authorized_keys</b>
$ <b>scp ~/.ssh/id_ecdsa.pub target_2:.ssh/authorized_keys</b>
...
$ <b>scp ~/.ssh/id_ecdsa.pub target_N:.ssh/authorized_keys</b>
</pre>
	Note: the above commands will prompt for the passphrase, but once authorized_keys is in
	place (and ssh-agent is running with a correct passphrase, etc.), passphrases are no
	longer required.
    </li>
    <li>
	Starting ssh-agent with start-ssh-agent:
<pre>
$ <b>. start-ssh-agent</b>	# Note: "dot" this script to configure this shell's environment
ssh-agent for tux not running: starting
==================== ==================== ====================
PASSPHRASE PASSPHRASE PASSPHRASE PASSPHRASE PASSPHRASE
==================== ==================== ====================
Enter passphrase for /home/tux/.ssh/id_ecdsa: <font color="red">Type the same passphrase as above here.</font>
Identity added: /home/tux/.ssh/id_ecdsa (/home/tux/.ssh/id_ecdsa)
SSH_AUTH_SOCK=/tmp/ssh-9ZtlUMecHR0y/agent.3938; export SSH_AUTH_SOCK;
SSH_AGENT_PID=3940; export SSH_AGENT_PID;
</pre>
If ssh-agent should normally always be running, lines like these can be added to .bashrc or .profile (as
appropriate) so the user will be prompted to start ssh-agent upon first login whenver it's not running.
<pre>
STARTSSHAGENTFILE=/usr/local/bin/start-ssh-agent
if [ -r $STARTSSHAGENTFILE ]; then
    .  $STARTSSHAGENTFILE
fi
</pre>
    </li>
    <li>
	Stopping ssh-agent with stop-ssh-agent:
<pre>
$ <b>. stop-ssh-agent</b>	# Note: "dot" this script to re/unconfigure this shell's environment
tux     4053     1  0 15:13 ?        00:00:00 ssh-agent
Killing ssh-agent PID(s) 4053 for tux
unset SSH_AUTH_SOCK;
unset SSH_AGENT_PID;
echo Agent pid 4053 killed;
</pre>
    </li>
</ol>

</body>
</html>
